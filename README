Copyright (c) 2010-2017 Google, Inc. licensed under the terms of the BSD.  All other rights reserved.
Copyright (c) 2000-2010 VMware, Inc. licensed under the terms of the BSD.  All other rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of VMware, Inc. nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

**********************************************************
About DynamoRIO

DynamoRIO is a runtime code manipulation system that supports code
transformations on any part of a program, while it executes. DynamoRIO
exports an interface for building dynamic tools for a wide variety of uses:
program analysis and understanding, profiling, instrumentation,
optimization, translation, etc. Unlike many dynamic tool systems, DynamoRIO
is not limited to insertion of callouts/trampolines and allows arbitrary
modifications to application instructions via a powerful IA-32/AMD64/ARM/AArch64
instruction manipulation library. DynamoRIO provides efficient,
transparent, and comprehensive manipulation of unmodified applications
running on stock operating systems (Windows, Linux, or Android) and commodity
IA-32, AMD64, ARM, and AArch64 hardware.

The DynamoRIO home page:

  http://dynamorio.org/

************************************************************
Branch Notes: Experimental JIT Optimization

This branch was developed during a Google Summer of Code project in 2015 to
address i#1114. For a detailed description of the implementation, see:

    http://dl.acm.org/citation.cfm?id=2738610

For a quick overview of the changes on this branch, use command:

    git diff master --stat

The special handling of DGC appears in the 3 files with the largest change sets:

    * core/jitopt.c
      - manages double-mapped pages
      - maintains bookkeeping of DGC fragments in a bucket/hashtable
      - selectively flushes fragments as requested by JIT writers
    * core/arch/x86/mangle.c
      - instruments JIT writer instrs to selectively flush fragments as necessary
    * core/vmareas.c:
      - integrates JIT code regions into the vmarea accounting structures
      - synchronizes double-mappings with any changes to corresponding vmarea

In core/jitopt.c, the bucket/hashtable was an experimental approach that we
found too difficult to maintain, particularly because the remove operation is
too complicated. The advantage of this structure is that it can easily be read
from the code cache, but we found it unnecessary to do so--in the Octane
benchmarks, it is sufficient to detect page-level overlap from the cache, and
check for exact fragment overlap after exiting to DR. So the page hashtable will
be kept, but the bucket/hashtable will be replaced by a red/black tree, which
has already been implemented in core/jit_opt.c.

The workflow for this branch is to progressively implement features as
individual commits on the project-optimize-jit branch. Code in core/jitopt.c
will be selectively migrated into core/jit_opt.c, and the experimental file
core/jitopt.c will eventually be deleted.

It is important to keep in mind that the developer who wrote all of the code in
this branch had only been programming in C for 2 years, and DynamoRIO is the
only C project he had ever worked on (all of his experience was in Java, not
even C++). the code is functionally correct, though may exhibit some unusual
structure, and certain annotative elements like const may be used incorrectly.
There are also a few fragments of commented code, along with extensive "release
logging", most of which should probably not be committed to master in any form.
If the logging is useful, it should be converted to use the standard DR logging
mechanism, with a more formal provision for logging in release mode if necessary
(since the Octane benchmarks take multiple days to run in a debug build of DR).


************************************************************
Quickstart instructions for running DynamoRIO:

--------------------------------------------------
On Linux:

To run the application with a DynamoRIO sample client:
32-bit:
  % bin32/drrun -c samples/bin32/libbbsize.so -- ls
64-bit:
  % bin64/drrun -c samples/bin64/libbbsize.so -- ls

To run the application with a DynamoRIO-based tool:
32-bit:
  % bin32/drrun -t drcachesim -- ls
64-bit
  % bin64/drrun -t drcachesim -- ls

To run the Dr. Memory tool which is included in release packages:
  % bin32/drrun -t drmemory -- <my-32-bit-app> <args-to-app>

For additional options and to list available tools for -t:
  % bin32/drrun -help

For full control over child processes use a two-step process:
first configure with bin32/drconfig and then invoke the parent
process with bin32/drinject.

--------------------------------------------------
On Windows, with examples run from a cygwin shell (for cmd shell replace
the first slash with a backward slash: e.g., bin32\drrun.exe):

Method 1: directly invoke an application:
To run the application with a DynamoRIO sample client:
32-bit
  % bin32/drrun.exe -c samples/bin32/bbsize.dll -- notepad
64-bit
  % bin64/drrun.exe -c samples/bin64/bbsize.dll -- notepad

To run the application with a DynamoRIO-based tool:
32-bit
  % bin32/drrun.exe -t drstrace -- notepad
64-bit
  % bin64/drrun.exe -t drstrace -- notepad

To run the Dr. Memory tool which is included in release packages:
  % bin32/drrun.exe -t drmemory -- <my-32-bit-app> <args-to-app>

For additional options and to list available tools for -t:
  % bin32/drrun.exe -help

Method 2: configure an application and launch it separately.
This requires administrative privileges:
32-bit:
  % bin32/drconfig.exe -reg notepad.exe -syswide_on -c samples/bin32/bbsize.dll
64-bit:
  % bin64/drconfig.exe -reg notepad.exe -syswide_on -c samples/bin64/bbsize.dll
Now run the application however you normally would, with the mouse or from
the command line.  From a cygwin shell this will run 32-bit notepad:
  % cmd /c start notepad

Now close notepad and a messagebox should pop up produced by the bbsize client.

Note that if you use cygwin unzip to extract files from the release package
.zip file, you'll need to mark all the .dll and .exe files as ugo+rx in
order to execute them.

************************************************************
Instructions for building:

If you are building from source, please see the DynamoRIO wiki for
information on the required tools on both Windows and Linux:

https://github.com/DynamoRIO/dynamorio/wiki/How-To-Build

************************************************************
Getting help and reporting bugs:

Query the DynamoRIO users group mailing list/discussion forum:

  http://groups.google.com/group/dynamorio-users

Use the Issue Tracker:

  http://dynamorio.org/issues

************************************************************
